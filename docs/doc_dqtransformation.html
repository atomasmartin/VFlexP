<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script type="text/javascript" src="scripts/MathJax_conf.js">
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">

        </script>
        <script type="text/javascript" src="scripts/switch_themes.js">
        </script>
        <script type="text/javascript" src="scripts/load_theme.js">
        </script>
        <script type="text/javascript" src="scripts/load_sidebar.js"></script>
        <link rel="stylesheet" id="css_style">
    <script type="text/javascript">
        var incx = 0;
        function alpha_beta(incx) { // abc (horizontal) to alpha-beta (vector)
            
            // abc (horizontal)
            var scale = 1.5;
            var alpha_beta = document.getElementById("alpha_beta").getContext("2d");
            var xOffset = 0;
            var yOffset = 0;
            var x = 0;
            var y = 0;
            var pi = Math.PI;
            var phi = 0;
            alpha_beta.lineWidth = 1;
            var sine_variable = (x+incx)/15.9154;
            
            alpha_beta.beginPath();
            if (localStorage.getItem("theme") == "light") {
                axis_color = 'black';
                phasea_color = 'red';
                phaseb_color = 'green';
                phasec_color = 'blue';
            } else {
                axis_color = 'white';
                phasea_color = 'orange';
                phaseb_color = 'red';
                phasec_color = 'yellow';
            }
            document.getElementById("Va").style.color = phasea_color;
            document.getElementById("Vb").style.color = phaseb_color;
            document.getElementById("Vc").style.color = phasec_color;
            alpha_beta.strokeStyle = axis_color;
            alpha_beta.moveTo(xOffset, scale*100+yOffset);
            alpha_beta.lineTo(scale*100+xOffset, scale*100+yOffset);
            alpha_beta.moveTo(scale*50+xOffset, scale*50+yOffset);
            alpha_beta.lineTo(scale*50+xOffset, scale*150+yOffset);
            alpha_beta.stroke();
            alpha_beta.beginPath();
            alpha_beta.strokeStyle = phasea_color;
            alpha_beta.lineWidth = 2;
            alpha_beta.moveTo(x+xOffset, scale*100+yOffset + Aa * scale*40 * Math.sin(sine_variable+phi)); // a phase
            while (x < 100) {
                sine_variable = (x+incx)/15.9154;
                alpha_beta.lineTo(scale*x+xOffset, scale*100+yOffset + Aa * scale*40 * Math.sin(sine_variable+phi));
                x++;
            }
            alpha_beta.stroke();
            alpha_beta.beginPath();
            x = 0;
            alpha_beta.strokeStyle = phaseb_color;
            alpha_beta.moveTo(scale*x+xOffset, scale*100+yOffset + Ab * scale*40 * Math.sin(sine_variable+4*pi/3+phi)); // b phase
            while (x < 100) {
                sine_variable = (x+incx)/15.9154;
                alpha_beta.lineTo(scale*x+xOffset, scale*100+yOffset + Ab * scale*40 * Math.sin(sine_variable+4*pi/3+phi));
                x++;
            }
            alpha_beta.stroke();
            alpha_beta.beginPath();
            x = 0;
            alpha_beta.strokeStyle = phasec_color;
            alpha_beta.moveTo(scale*x+xOffset, scale*100+yOffset + Ac * scale*40 * Math.sin(sine_variable+2*pi/3+phi)); // c phase
            while (x < 100) {
                sine_variable = (x+incx)/15.9154;
                alpha_beta.lineTo(scale*x+xOffset, scale*100+yOffset + Ac * scale*40 * Math.sin(sine_variable+2*pi/3+phi));
                x++;
            }
            alpha_beta.stroke();
            
            // Alpha - beta reference frame
            xOffset = scale*100;
            yOffset = 0;
            x = 0;
            sine_variable = (x+incx)/15.9154;
            alpha_beta.lineWidth = 1;
            alpha_beta.beginPath();
            alpha_beta.strokeStyle = axis_color;
            alpha_beta.moveTo(scale*50+xOffset, scale*100+yOffset);
            alpha_beta.lineTo(scale*150+xOffset, scale*100+yOffset);
            alpha_beta.moveTo(scale*100+xOffset, scale*50+yOffset);
            alpha_beta.lineTo(scale*100+xOffset, scale*150+yOffset);
            alpha_beta.stroke();
            alpha_beta.beginPath();
            alpha_beta.strokeStyle = phasea_color;
            alpha_beta.lineWidth = 2;
            // Dashed line
            alpha_beta.setLineDash([5, 5]);
            alpha_beta.moveTo(scale*100+xOffset + Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi), scale*100 + -(Aa * 0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi))+yOffset);
            var pi = Math.PI;
            alpha_beta.lineTo(scale*100+xOffset, scale*100 + -(Aa * scale*0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi))+yOffset);
            alpha_beta.stroke();
            
            alpha_beta.beginPath();
            alpha_beta.strokeStyle = phaseb_color;
            alpha_beta.lineWidth = 2;
            alpha_beta.moveTo(scale*100+xOffset + Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi), scale*100 + -(Aa * 0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi))+yOffset);
            var pi = Math.PI;
            alpha_beta.lineTo(scale*100+xOffset + (Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi)), scale*100+yOffset);
            alpha_beta.stroke();
            alpha_beta.setLineDash([]);
            
            
            alpha_beta.beginPath();
            alpha_beta.strokeStyle = phasec_color;
            alpha_beta.lineWidth = 2;
            alpha_beta.moveTo(scale*100+xOffset, scale*100+yOffset);
            var pi = Math.PI;
            alpha_beta.lineTo(scale*100+xOffset + Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi), scale*100 + -(Aa * 0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi))+yOffset);
            alpha_beta.arc(scale*100+xOffset + Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi), scale*100 + -(Aa * 0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi))+yOffset, 3, 0, 2 * Math.PI, false);
            alpha_beta.stroke();
            
            alpha_beta.font = "20px Arial";
            alpha_beta.fillStyle = axis_color;
            alpha_beta.fillText("\u0251", scale*150+xOffset, scale*100+20+yOffset);
            alpha_beta.fillText("\u03b2", scale*100+xOffset-20, scale*50+yOffset);
            
            // Homopolar axis
            alpha_beta.beginPath();
            alpha_beta.strokeStyle = axis_color;
            alpha_beta.lineWidth = 1;
            alpha_beta.moveTo(scale*150+1.5*xOffset, scale*50+yOffset);
            alpha_beta.lineTo(scale*150+1.5*xOffset, scale*150+yOffset);
            alpha_beta.moveTo(scale*150+1.4*xOffset, scale*100+yOffset);
            alpha_beta.lineTo(scale*150+1.6*xOffset, scale*100+yOffset);
            alpha_beta.moveTo(scale*150+1.5*xOffset, scale*100+yOffset);
            alpha_beta.stroke();
            
            alpha_beta.beginPath();
            alpha_beta.strokeStyle = phasea_color;
            alpha_beta.moveTo(scale*150+1.5*xOffset, scale*100+yOffset);
            alpha_beta.lineTo(scale*150+1.5*xOffset, scale*100 + -(Aa * scale*15 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) + Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi))+yOffset);
            alpha_beta.arc(scale*150+1.5*xOffset, scale*100 + -(Aa * scale*15 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) + Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi))+yOffset, 3, 0, 2 * Math.PI, false);
            alpha_beta.stroke();
            alpha_beta.fillText("0", scale*150+1.5*xOffset, scale*150+yOffset+20);
        }
        function d_q(incx) {
            
            // alpha-beta to d-q
            var scale = 1.5;
            var d_q = document.getElementById("d_q").getContext("2d");
            var xOffset = 75;
            var yOffset = 0;
            var x = 0;
            var y = 0;
            var pi = Math.PI;
            var phi = 0;
            d_q.lineWidth = 1;
            
            var sine_variable = (x+incx)/15.9154;
            
            
            // Voltage vector
            d_q.beginPath();
            d_q.strokeStyle = phasec_color;
            d_q.lineWidth = 2;
            d_q.moveTo(scale*50+xOffset, scale*100+yOffset);
            var pi = Math.PI;
            d_q.lineTo(scale*50+xOffset + Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi), scale*100 + -(Aa * 0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi))+yOffset);
            d_q.arc(scale*50+xOffset + Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi), scale*100 + -(Aa * 0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi))+yOffset, 3, 0, 2 * Math.PI, false);
            d_q.stroke();
            
            // d-q axis
            d_q.lineWidth = 1;
            d_q.beginPath();
            d_q.strokeStyle = axis_color;
            d_q.moveTo(scale*50+xOffset, scale*100+yOffset);
            // d-axis
            d_final_x = 1 * scale*35 * Math.sin(sine_variable+phi+phi_aq) - 1 * scale*17.5 * Math.sin(sine_variable+4*pi/3+phi+phi_aq) - 1 * scale*17.5 * Math.sin(sine_variable+2*pi/3+phi+phi_aq);
            d_final_y = -(1 * 0 * Math.sin(sine_variable+phi+phi_aq) + 1 * scale*17.5 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi+phi_aq) - 1 * scale*17.5 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi+phi_aq));
            d_q.lineTo(scale*50+xOffset + d_final_x, scale*100+yOffset + d_final_y);
            d_q.moveTo(scale*50+xOffset, scale*100+yOffset);
            // q-axis, 90 degrees ahead of d-axis, so add pi/2
            q_final_x = 1 * scale*35 * Math.sin(sine_variable+phi+phi_aq+pi/2) - 1 * scale*17.5 * Math.sin(sine_variable+4*pi/3+phi+phi_aq+pi/2) - 1 * scale*17.5 * Math.sin(sine_variable+2*pi/3+phi+phi_aq+pi/2);
            q_final_y = -(1 * 0 * Math.sin(sine_variable+phi+phi_aq+pi/2) + 1 * scale*17.5 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi+phi_aq+pi/2) - 1 * scale*17.5 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi+phi_aq+pi/2));
            d_q.lineTo(scale*50+xOffset + q_final_x, scale*100 + q_final_y +yOffset);
            d_q.stroke();
            
            // label d-q axis with rotating text
            // Rotate the context and draw the text
            d_q.save();
            aux_x = scale*50+xOffset + 1 * scale*35 * Math.sin(sine_variable+phi+phi_aq) - 1 * scale*17.5 * Math.sin(sine_variable+4*pi/3+phi+phi_aq) - 1 * scale*17.5 * Math.sin(sine_variable+2*pi/3+phi+phi_aq);
            aux_y = scale*100 + -(1 * 0 * Math.sin(sine_variable+phi+phi_aq) + 1 * scale*17.5 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi+phi_aq) - 1 * scale*17.5 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi+phi_aq))+yOffset;
            d_q.translate(aux_x, aux_y);
            d_q.rotate(pi-sine_variable+phi-phi_aq);
            
            d_q.font = "20px Arial";
            d_q.fillStyle = axis_color;
            d_q.fillText("d", 0,0);
            d_q.fillText("q", -scale*65, scale*50);
            
            d_q.restore();
            
            // Dashed lines to dq axis projection
            d_q.lineWidth = 1;
            d_q.beginPath();
            d_q.strokeStyle = phasea_color;
            d_q.setLineDash([5, 5]);
            aux_x = Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi);
            aux_y = -(Aa * 0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi));
            d_q.moveTo(scale*50+xOffset + aux_x, scale*100 + aux_y +yOffset);
            sine_variable = (x+incx)/15.9154;
            
            mod_v = Math.sqrt(aux_x*aux_x + aux_y*aux_y)/(scale*50);
            var firstAngle = Math.atan2(aux_x, aux_y);
            var secondAngle = Math.atan2(d_final_x, d_final_y);
            var angle = firstAngle - secondAngle;
            
            d_component = Math.cos(angle)*mod_v;
            q_component = Math.sin(angle)*mod_v;
            d_q.lineTo(scale*50+xOffset + d_component*d_final_x, scale*100 + d_component*d_final_y+yOffset);
            d_q.stroke();
            d_q.strokeStyle = phaseb_color;
            d_q.moveTo(scale*50+xOffset + aux_x, scale*100 + aux_y +yOffset);
            d_q.lineTo(scale*50+xOffset + q_component*q_final_x, scale*100 + q_component*q_final_y+yOffset);
            
            
            d_q.stroke();
            d_q.setLineDash([]);
            
            
            
            // D - Q reference frame
            xOffset = 75+scale*100;
            yOffset = 0;
            x = 0;
            d_q.lineWidth = 1;
            d_q.beginPath();
            d_q.strokeStyle = axis_color;
            d_q.moveTo(scale*50+xOffset, scale*100+yOffset);
            d_q.lineTo(scale*150+xOffset, scale*100+yOffset);
            d_q.moveTo(scale*100+xOffset, scale*50+yOffset);
            d_q.lineTo(scale*100+xOffset, scale*150+yOffset);
            d_q.stroke();
            d_q.setLineDash([5, 5]);
            d_q.beginPath();
            d_q.strokeStyle = phasea_color;
            d_q.lineWidth = 2;
            d_q.moveTo(scale*100+xOffset + scale*50*d_component, scale*100 - scale*50*q_component +yOffset);
            var pi = Math.PI;
            d_q.lineTo(scale*100+xOffset, scale*100 - scale*50*q_component +yOffset);
            d_q.stroke();
            
            d_q.beginPath();
            d_q.strokeStyle = phaseb_color;
            d_q.lineWidth = 2;
            d_q.moveTo(scale*100+xOffset + scale*50*d_component, scale*100 - scale*50*q_component +yOffset);
            var pi = Math.PI;
            d_q.lineTo(scale*100+xOffset + scale*50*d_component, scale*100+yOffset);
            d_q.stroke();
            d_q.setLineDash([]);
            
            
            d_q.beginPath();
            d_q.strokeStyle = phasec_color;
            d_q.lineWidth = 2;
            d_q.moveTo(scale*100+xOffset, scale*100+yOffset);
            var pi = Math.PI;
            d_q.lineTo(scale*100+xOffset + scale*50*d_component, scale*100 - scale*50*q_component +yOffset);
            d_q.arc(scale*100+xOffset + scale*50*d_component, scale*100 - scale*50*q_component +yOffset, 3, 0, 2 * Math.PI, false);
            d_q.stroke();
            
            d_q.font = "20px Arial";
            d_q.fillStyle = axis_color;
            d_q.fillText("d", scale*150+xOffset, scale*100+yOffset+20);
            d_q.fillText("q", scale*100+xOffset-20, scale*50+yOffset);
            
        }
        function abc_dq(incx) {
            
            // abc (horizontal)
            var scale = 1.5;
            var abc_dq = document.getElementById("abc_dq").getContext("2d");
            var xOffset = 75;
            var yOffset = 0;
            var x = 0;
            var y = 0;
            var pi = Math.PI;
            var phi = 0;
            abc_dq.lineWidth = 1;
            var sine_variable = (x+incx)/15.9154;
            
            abc_dq.beginPath();
            if (localStorage.getItem("theme") == "light") {
                axis_color = 'black';
                phasea_color = 'red';
                phaseb_color = 'green';
                phasec_color = 'blue';
            } else {
                axis_color = 'white';
                phasea_color = 'orange';
                phaseb_color = 'red';
                phasec_color = 'yellow';
            }
            document.getElementById("Va").style.color = phasea_color;
            document.getElementById("Vb").style.color = phaseb_color;
            document.getElementById("Vc").style.color = phasec_color;
            abc_dq.strokeStyle = axis_color;
            abc_dq.moveTo(xOffset, scale*100+yOffset);
            abc_dq.lineTo(scale*100+xOffset, scale*100+yOffset);
            abc_dq.moveTo(scale*50+xOffset, scale*50+yOffset);
            abc_dq.lineTo(scale*50+xOffset, scale*150+yOffset);
            abc_dq.stroke();
            abc_dq.beginPath();
            abc_dq.strokeStyle = phasea_color;
            abc_dq.lineWidth = 2;
            abc_dq.moveTo(x+xOffset, scale*100+yOffset + Aa * scale*40 * Math.sin(sine_variable+phi)); // a phase
            while (x < 100) {
                sine_variable = (x+incx)/15.9154;
                abc_dq.lineTo(scale*x+xOffset, scale*100+yOffset + Aa * scale*40 * Math.sin(sine_variable+phi));
                x++;
            }
            abc_dq.stroke();
            abc_dq.beginPath();
            x = 0;
            abc_dq.strokeStyle = phaseb_color;
            abc_dq.moveTo(scale*x+xOffset, scale*100+yOffset + Ab * scale*40 * Math.sin(sine_variable+4*pi/3+phi)); // b phase
            while (x < 100) {
                sine_variable = (x+incx)/15.9154;
                abc_dq.lineTo(scale*x+xOffset, scale*100+yOffset + Ab * scale*40 * Math.sin(sine_variable+4*pi/3+phi));
                x++;
            }
            abc_dq.stroke();
            abc_dq.beginPath();
            x = 0;
            abc_dq.strokeStyle = phasec_color;
            abc_dq.moveTo(scale*x+xOffset, scale*100+yOffset + Ac * scale*40 * Math.sin(sine_variable+2*pi/3+phi)); // c phase
            while (x < 100) {
                sine_variable = (x+incx)/15.9154;
                abc_dq.lineTo(scale*x+xOffset, scale*100+yOffset + Ac * scale*40 * Math.sin(sine_variable+2*pi/3+phi));
                x++;
            }
            abc_dq.stroke();

            abc_dq.font = "20px Arial";
            abc_dq.fillStyle = phasea_color;
            abc_dq.fillText("a", 50, 50);
            abc_dq.fillStyle = phaseb_color;
            abc_dq.fillText("b", 70, 50);
            abc_dq.fillStyle = phasec_color;
            abc_dq.fillText("c", 90, 50);

            
            // D - Q reference frame
            xOffset = 75+scale*100;
            yOffset = 0;
            x = 0;
            sine_variable = (x+incx)/15.9154;
            aux_x = Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi);
            aux_y = -(Aa * 0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi));
            sine_variable = (x+incx)/15.9154;
            
            mod_v = Math.sqrt(aux_x*aux_x + aux_y*aux_y)/(scale*50);
            var firstAngle = Math.atan2(aux_x, aux_y);
            var secondAngle = Math.atan2(d_final_x, d_final_y);
            var angle = firstAngle - secondAngle;
            
            d_component = Math.cos(angle)*mod_v;
            q_component = Math.sin(angle)*mod_v;
            
            abc_dq.lineWidth = 1;
            abc_dq.beginPath();
            abc_dq.strokeStyle = axis_color;
            abc_dq.moveTo(scale*50+xOffset, scale*100+yOffset);
            abc_dq.lineTo(scale*150+xOffset, scale*100+yOffset);
            abc_dq.moveTo(scale*100+xOffset, scale*50+yOffset);
            abc_dq.lineTo(scale*100+xOffset, scale*150+yOffset);
            abc_dq.stroke();
            abc_dq.beginPath();
            abc_dq.strokeStyle = phaseb_color;
            abc_dq.lineWidth = 2;
            while (x < 100) {
                sine_variable = (x+incx)/15.9154;
                
                d_final_x = 1 * scale*35 * Math.sin(sine_variable+phi+phi_aq) - 1 * scale*17.5 * Math.sin(sine_variable+4*pi/3+phi+phi_aq) - 1 * scale*17.5 * Math.sin(sine_variable+2*pi/3+phi+phi_aq);
                d_final_y = -(1 * 0 * Math.sin(sine_variable+phi+phi_aq) + 1 * scale*17.5 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi+phi_aq) - 1 * scale*17.5 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi+phi_aq));
                
                aux_x = Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi);
                aux_y = -(Aa * 0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi));
                sine_variable = (x+incx)/15.9154;
                
                mod_v = Math.sqrt(aux_x*aux_x + aux_y*aux_y)/(scale*50);
                firstAngle = Math.atan2(aux_x, aux_y);
                secondAngle = Math.atan2(d_final_x, d_final_y);
                angle = firstAngle - secondAngle;
                
                d_component = 0.9*Math.cos(angle)*mod_v;
                q_component = 0.9*Math.sin(angle)*mod_v;
                abc_dq.lineTo(scale*50+scale*x+xOffset, -d_component*scale*50+scale*100+yOffset);
                x++;
            }
            abc_dq.stroke();
            abc_dq.beginPath();
            x = 0;
            abc_dq.strokeStyle = phasea_color;
            while (x < 100) {
                sine_variable = (x+incx)/15.9154;
                
                d_final_x = 1 * scale*35 * Math.sin(sine_variable+phi+phi_aq) - 1 * scale*17.5 * Math.sin(sine_variable+4*pi/3+phi+phi_aq) - 1 * scale*17.5 * Math.sin(sine_variable+2*pi/3+phi+phi_aq);
                d_final_y = -(1 * 0 * Math.sin(sine_variable+phi+phi_aq) + 1 * scale*17.5 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi+phi_aq) - 1 * scale*17.5 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi+phi_aq));
                
                aux_x = Aa * scale*30 * Math.sin(sine_variable+phi) - Ab * scale*15 * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sin(sine_variable+2*pi/3+phi);
                aux_y = -(Aa * 0 * Math.sin(sine_variable+phi) + Ab * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+4*pi/3+phi) - Ac * scale*15 * Math.sqrt(3) * Math.sin(sine_variable+2*pi/3+phi));
                sine_variable = (x+incx)/15.9154;
                
                mod_v = Math.sqrt(aux_x*aux_x + aux_y*aux_y)/(scale*50);
                firstAngle = Math.atan2(aux_x, aux_y);
                secondAngle = Math.atan2(d_final_x, d_final_y);
                angle = firstAngle - secondAngle;
                
                d_component = 0.9*Math.cos(angle)*mod_v;
                q_component = 0.9*Math.sin(angle)*mod_v;
                abc_dq.lineTo(scale*50+scale*x+xOffset, -q_component*scale*50+scale*100+yOffset);
                x++;
            }
            abc_dq.stroke();

            abc_dq.font = "20px Arial";
            abc_dq.fillStyle = phaseb_color;
            abc_dq.fillText("d", 50+xOffset, 50);
            abc_dq.fillStyle = phasea_color;
            abc_dq.fillText("q", 70+xOffset, 50);
        }
        var aincx = 1; // initial value of the slider
        var Aa = 1; Ab = 1; Ac = 1; // Amplitudes of the 3 phases
        var phi_aq = 0; // Phase shift between phase a and q axis
        function draw() {
            document.getElementById("alpha_beta").getContext("2d").clearRect(0, 0, 5000, 5000);
            alpha_beta(incx)
            document.getElementById("d_q").getContext("2d").clearRect(0, 0, 5000, 5000);
            document.getElementById("abc_dq").getContext("2d").clearRect(0, 0, 5000, 5000);
            d_q(incx)
            abc_dq(incx)
            incx += aincx;
            try {
                if (document.getElementById("draw_animation").checked) {
                    requestAnimationFrame(draw);
                }
            } catch (error) {
                console.log(error);
            }
        }
    </script>
    <style>
        input[type="range"] {
            appearance: none;
            width: 200px;
            height: 5px;
            background-color: #ddd;
            outline: none;
            margin: 10px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border-radius: 25px;
            width: 15px;
            height: 15px;
            background-color: #ff0000; /* Change this to the desired color */
            cursor: pointer;
        }
    </style>
</head>
<body onload="load_theme(),requestAnimationFrame(draw),updateSliderTrack(20)">
    <script>
        load_theme_pre();
    </script>
    <script>
        theme_button = document.getElementById("theme_button");
        theme_button.addeventlistener("click", function() {
            switch_themes();
            requestAnimationFrame(draw);
        });
        function updateSliderTrack(value) {
            const track = document.querySelector('input[type="range"]');
            track.style.background = `linear-gradient(to right, #ff0000 0%, #ff0000 \(
{value}%, #bbb \)

{value}%, #bbb 100%)`;
            aincx = 0.02*Number(value);
        }
    </script>
    <div id="sidebar"></div><div id="right_sidebar"></div>
    
    <div id="main_content">

        <h1 class="text-center text-blue-800">Understanding Alpha-Beta (\(
\alpha\beta\)

) and dq0 Axes in 3-Phase Systems</h1>

        <p class="mb-6 text-lg text-center text-gray-700">
            In electrical engineering, especially with AC machines and power electronics, analyzing three-phase systems can be complex. This is where transformations like Alpha-Beta (\(
\alpha\beta\)

) and \(
dq0\)

 come in handy.
        </p>

        <hr class="border-t-2 border-gray-200 my-6">

        <h2>What are Alpha-Beta (\(
\alpha\beta\)

) Axes?</h2>
        <p>
            The Alpha-Beta (\(
\alpha\beta\)

) axes form a stationary two-axis reference frame. They are the core of the Clarke transformation, which converts three-phase quantities (like voltages or currents) into a simpler, two-dimensional representation.
        </p>
        <ul class="list-disc ml-6 mb-4">
            <li>
                The Alpha (\(
\alpha\)

) axis is typically aligned with one of the original three-phase axes (e.g., phase 'a').
            </li>
            <li>
                The Beta (\(
\beta\)

) axis is orthogonal (at 90 degrees) to the alpha axis.
            </li>
            <li>
                There's also a zero-sequence (0) component for common-mode or unbalanced parts of the system. For balanced systems, this component is zero.
            </li>
        </ul>
        <p>
            This transformation simplifies analysis by representing three interdependent AC quantities as two orthogonal components in a stationary plane.
        </p>

        <hr class="border-t-2 border-gray-200 my-6">

        <h2>The Clarke Transformation Matrix</h2>
        <p>
            The transformation from the three-phase (\(
abc\)

) frame to the alpha-beta-zero (\(
\alpha\beta0\)

) frame is given by:
        </p>
        <p>
            For balanced three-phase systems, the 0 component is zero, meaning all the information is contained within the two-dimensional \(
\alpha\beta\)

 plane.
        </p>

        <hr class="border-t-2 border-gray-200 my-6">

        <h2>What are DQ0 (\(
dq0\)

) Axes?</h2>
        <p>
            The DQ0 (\(
dq0\)

) axes form a rotating two-axis reference frame. This transformation, known as the Park transformation, takes the quantities from the stationary \(
\alpha\beta\)

 frame and rotates them at the same speed as the system's rotating magnetic field.
        </p>
        <ul class="list-disc ml-6 mb-4">
            <li>
                The Direct (\(
d\)

) axis is typically aligned with the magnetic flux.
            </li>
            <li>
                The Quadrature (\(
q\)

) axis is orthogonal (90 degrees) to the direct axis.
            </li>
            <li>
                The zero-sequence (0) component remains the same as in the Clarke transformation.
            </li>
        </ul>
        <p>
            The key advantage of the Park transformation is that for a balanced AC system, the time-varying sinusoidal quantities in the \(
abc\)

 frame become constant (DC) quantities in the \(
dq\)

 frame. This simplifies control algorithms immensely, allowing standard DC controllers like Proportional-Integral (PI) controllers to be used effectively.
        </p>

        <hr class="border-t-2 border-gray-200 my-6">

        <h2>Advantages and Applications of (\(
\alpha\beta\)

) and dq0 Transformations</h2>
        <p>
            These transformations offer significant benefits in the control and analysis of AC electrical systems:
        </p>
        <ol class="list-decimal ml-6">
            <li>
                <h3>Simplification of Analysis:</h3>
                <p>
                    They reduce complex time-varying three-phase systems to simpler two-dimensional stationary (\(
\alpha\beta\)

) or DC-equivalent (\(
dq\)

) representations.
                </p>
            </li>
            <li>
                <h3>Decoupling of Components:</h3>
                <p>
                    Both transformations help separate balanced components from the zero-sequence, aiding in fault detection and imbalance analysis.
                </p>
            </li>
            <li>
                <h3>Enhanced Control:</h3>
                <p>
                    The \(
dq0\)

 transformation is crucial for Field-Oriented Control (FOC) of AC motors, enabling independent control of torque and flux. This leads to high-performance motor drives.
                </p>
            </li>
            <li>
                <h3>Computational Efficiency:</h3>
                <p>
                    Working with fewer variables and simpler dynamics allows for more efficient control algorithms and real-time processing.
                </p>
            </li>
        </ol>

        <h3>Key Applications:</h3>
        <ul class="list-disc ml-6">
            <li>
                <h4>Motor Drives:</h4>
                <p>
                    Fundamental for advanced control of induction and synchronous motors (FOC), ensuring precise and efficient operation.
                </p>
            </li>
            <li>
                <h4>Power Electronics:</h4>
                <p>
                    Widely used in control algorithms for inverters, rectifiers, and STATCOMs to simplify control structures.
                </p>
            </li>
            <li>
                <h4>Power System Analysis:</h4>
                <p>
                    Aids in analyzing unbalanced conditions, fault detection, and power quality assessment.
                </p>
            </li>
        </ul>

        <hr class="border-t-2 border-gray-200 my-6">

        <p class="text-center text-gray-600 italic">
            By transforming complex three-phase variables into more manageable reference frames, the alpha-beta and DQ0 axes are indispensable tools in modern electrical engineering.
        </p>

        <hr class="border-t-2 border-gray-200 my-6">

        <p class="text-center text-gray-600 italic">
            By simplifying complex three-phase variables into a more manageable two-dimensional space, the alpha-beta axes and the Clarke transformation are indispensable tools in modern electrical engineering.
        </p>
        </p>
        <br>
        <br>
        <img src="figures/alpha_beta_frame.png" width="300px">
        <br>
        <img src="figures/d_q_frame.png" width="300px">
        <br><br>
        <b>Instructions:</b>
        <br>
        <ul>
            <li>Use the number inputs to change the amplitude of the 3 phases.</li>
            <li>Use the slider to change the speed of the animation.</li>
            <li>Use the slider to change the phase shift between phase a and the d axis.</li>
            <li>Use the small slider just down here to start/stop the animation.</li>
        </ul>
        <br>
        <label class="switch">
            <input id="draw_animation" type="checkbox" onchange="if (this.checked) {requestAnimationFrame(draw);}">
            <span class="switch_round"></span>
          </label>
        <h2>3-phase signal in abc and &alpha;&beta;0  reference frame</h2>
        <b id="Va">Va</b> <input type="number" min="-1" max="1" value="1" step="0.1" onchange="if (Number(this.value) < -1) {Aa = -1; this.value = -1;} else if (Number(this.value) > 1) {Aa = 1; this.value = 1;} else {Aa = Number(this.value);}">
        <b id="Vb">Vb</b> <input type="number" min="-1" max="1" value="1" step="0.1" onchange="if (Number(this.value) < -1) {Ab = -1; this.value = -1;} else if (Number(this.value) > 1) {Ab = 1; this.value = 1;} else {Ab = Number(this.value);}">
        <b id="Vc">Vc</b> <input type="number" min="-1" max="1" value="1" step="0.1" onchange="if (Number(this.value) < -1) {Ac = -1; this.value = -1;} else if (Number(this.value) > 1) {Ac = 1; this.value = 1;} else {Ac = Number(this.value);}">
        <canvas id="alpha_beta" width="510" height="250" style="margin: 0 auto; display: block;"></canvas>
        <div class="slidecontainer">
            Speed
            <input type="range" min="0" max="100" value="20" step="1" class="slider" id="speed_slider" oninput="updateSliderTrack(this.value)">
        </div>
        <h2>3-phase signal in dq0 reference frame</h2>
        <b id="phi_aq">Initial phase between phase a and d axis</b> <input type="number" min="-180" max="180" value="0" step="15" onchange="phi_aq = Math.PI*Number(this.value)/180;">
        <canvas id="d_q" width="510" height="250" style="margin: 0 auto; display: block;"></canvas>
        <h2>3-phase signal in dq0 reference frame</h2>
        <canvas id="abc_dq" width="510" height="250" style="margin: 0 auto; display: block;"></canvas>
    </div>
</body>
</html>